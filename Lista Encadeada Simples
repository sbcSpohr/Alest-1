//uma maneira de interpretar os .prox é:

//aux.prox = node

//*o proximo do aux *sera* o node*



public class ListaEncadeada {

    private class Node {

        public int valor;
        public Node prox;

        public Node(int valor) {
            this.valor = valor;
            this.prox = null;
        }
    }

    private Node head;
    private Node tail;
    private int count;

    public ListaEncadeada() {
        this.head = null;
        this.tail = null;
        this.count = 0;
    }

    public void add(int valor) {
      
        Node node = new Node(valor);

        if (isEmpty()) {
            head = node;
            tail = node;
        }

        tail.prox = node; //o proximo do tail (tail.prox) sera o novo node //está atribuindo o novo nó (node) ao próximo nó do atual último nó da lista (tail).
        tail = node;
        count++;

        // ***********************
        // OUTRA IMPLEMENTAÇÃO
        /*
         Node aux = head;
         while(aux.prox != null){
         aux = aux.prox;
         }
         aux.prox = novo;

         count++;
         */
        // ***********************
    }

    public void add(int index, int valor){

      if(index < 0 || index >= count){
        throw new IndexOutOfBoundsException("Posicao inválida na lista");
      }

      if(index !=0){
        index--;
        Node aux = head;
          while(index > 0){
            aux = aux.prox;
            index--;
        }
          node.prox = aux.prox;
          aux.prox = node;
      } else {
            node.prox = head;
            head = node;
        }
    }

    public void remove(){

      if((index<0)||(index>=count){
        throw new IndexOutOfBoundsException("Posicao inválida na lista");
      }
        Nodo aux = head;
        if(index > 0){
        index--;
        while(index > 0){
        aux = aux.prox;
        index--;
    }

        Nodo die = aux.prox;
        aux.prox = die.prox;
        die.prox = null;

        count--;

}
    }

    public boolean isEmpty() {
        return (head == null);
    }

    public void clear() {
        head = null;
        count = 0;
    }

    public boolean contains(int valor) {
        Node aux = head;
        while (aux != null) {
            if (aux.valor == valor) {
                return true;
            }
            aux = aux.prox;
        }
        return false;

        // ***********************
        // OUTRA IMPLEMENTAÇÃO
        /*
        if(head.valor == valor){
         return true;
         }
         Node aux = head;
         while(aux.prox!=null){
         aux = aux.prox;
         if(aux.valor == valor){
         return true;
         }
         }
         return false;
         */
        // ***********************
    }
}
